# 前言

在前面的内容，我们一直讲的都是“**通常写法，函数模板、类模板、变量模板不能分文件**”。

并且阐述了原因，简单的说：**在于模板必须使用了才会生成实际的代码，才会有符号让链接器去链接**。

- **只有实例化模板，编译器才能生成实际的代码**。

> 需要注意，以前说的“**使用模板**”其实就是会 **[隐式实例化](https://zh.cppreference.com/w/cpp/language/function_template#.E9.9A.90.E5.BC.8F.E5.AE.9E.E4.BE.8B.E5.8C.96)模板**，编译器根据我们的使用，知道我们需要什么类型的模板，生成实际的代码，比如实际的函数，实际的类，实际的变量等，然后再去调用。

分文件这个问题显然是可以解决的，那就是：**显式实例化模板**。

我们自己指明，到底需要哪些具体的函数。

## 语法

### 函数模板显式实例化

```
template 返回类型 名字 < 实参列表 > ( 形参列表 ) ;	        (1)	
template 返回类型 名字 ( 形参列表 ) ;	                    (2)	
extern template 返回类型 名字 < 实参列表 > ( 形参列表 ) ;	(3)	(C++11 起)
extern template 返回类型 名字 ( 形参列表 ) ;	            (4)	(C++11 起)
```

1. 显式实例化定义（显式指定所有无默认值模板形参时不会推导模板实参）
2. 显式实例化定义，对所有形参进行模板实参推导
3. 显式实例化声明（显式指定所有无默认值模板形参时不会推导模板实参）
4. 显式实例化声明，对所有形参进行模板实参推导

**显式实例化定义强制实例化它所指代的函数或成员函数**。它可以出现在程序中模板定义后的任何位置，而对于给定的实参列表，它在整个程序中只能出现一次，不要求诊断。

显式实例化声明（extern 模板）阻止隐式实例化：本来会导致隐式实例化的代码必须改为使用已在程序的别处所提供的显式实例化。(C++11 起)

在函数模板特化或成员函数模板特化的显式实例化中，尾部的各模板实参在能从函数参数推导时不需要指定